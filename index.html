<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Ocaml-prog-pats by mmottl</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Ocaml-prog-pats</h1>
      <h2 class="project-tagline">OCaml Programming Patterns - random tricks, &quot;design patterns&quot;, etc.</h2>
      <a href="https://github.com/mmottl/ocaml-prog-pats" class="btn">View on GitHub</a>
      <a href="https://github.com/mmottl/ocaml-prog-pats/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/mmottl/ocaml-prog-pats/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="ocaml-programming-patterns" class="anchor" href="#ocaml-programming-patterns" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>OCaml Programming Patterns</h1>

<hr>

<h2>
<a id="purpose" class="anchor" href="#purpose" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Purpose</h2>

<p>This package contains some random programming tricks, "design patterns",
and other helpful or at least inspiring ideas of achieving a high level of
abstraction in OCaml programs that I have come across over time.  Some may
demonstrate how to implement concepts of more or less theoretical interest
(e.g. arrows, monads), others show more practical hints on how to structure
code to make it more reusable (e.g. abstract lexers, extensible ASTs).</p>

<h2>
<a id="contents" class="anchor" href="#contents" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Contents</h2>

<p>The package currently contains the following:</p>

<ul>
<li><a href="#abstract-lexer">Abstract Lexer</a></li>
<li><a href="#extensible-asts">Extensible ASTs</a></li>
<li><a href="#arrows">Arrows</a></li>
<li><a href="#union-find">Union find</a></li>
</ul>

<h3>
<a id="abstract-lexer" class="anchor" href="#abstract-lexer" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Abstract Lexer</h3>

<h4>
<a id="quick-introduction-to-syntactic-analysis" class="anchor" href="#quick-introduction-to-syntactic-analysis" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Quick introduction to syntactic analysis</h4>

<p>The first step in the process of compilation or interpretation of computer
programs or other formal languages is typically lexical and syntactic analysis,
or in other terms:</p>

<ol>
<li>Lexing</li>
<li>Parsing</li>
</ol>

<p>The process of lexing transforms a stream of <em>characters</em> (e.g. ANSI,
Unicode, etc.) to a stream of <em>tokens</em>, thus providing a more accessible
representation of the elements in the input.  This step might, for example,
identify keywords, numbers, operators, etc.  The process of parsing assigns
a grammatical structure to these elements, thus grouping them in ways that
allow us to interpret the input more easily.</p>

<h4>
<a id="purpose-of-the-abstract-lexer" class="anchor" href="#purpose-of-the-abstract-lexer" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Purpose of the abstract lexer</h4>

<p>The purpose of the <em>abstract lexer</em> is to fully separate steps one and two
above when using <code>ocamllex</code> to generate lexers.</p>

<p>Programmers typically implement lexers such that they generate a token
stream for a particular parser.  This is usually all they need so there is
no problem with that.  But sometimes requirements change and we may want to
use different parsers with the same lexer.</p>

<p>For example, the requirement for one parser might be optimum efficiency.
It may not want to deal with comments in an input file and rather ignore those
already during lexing.  We may want to avoid having to implement grammar
rules that take into account comment syntax in that case.  Other parsers,
however, might want to keep comments, for example to pretty-print transformed
input without losing this valuable information.</p>

<p>The <em>abstract lexer</em> achieves this separation by wrapping lexers generated by
<code>ocamllex</code> into a functor that abstracts over the types of values ("tokens")
returned by the lexer.</p>

<p>A lexer specification usually consists of several <em>rules</em> (functions).
These functions take the current state of the lexer, which specifies the
position in the input stream, and try to match one ore more <em>patterns</em>
(regular expressions) at the current location in the input stream.  If a
pattern matches, an associated action will be executed.</p>

<p>Instead of returning a specific parser token from within an action, which
would be the usual thing to do, abstract lexers call a function in the
functor argument and pass it whatever lexeme (or relevant part of a lexeme)
the lexer has just identified.  This function may then return a parser token
for whatever parser it is intended for.</p>

<p>Sometimes lexer rules may also call other lexer rules recursively.  In the
abstract lexer design, however, we never call other rules explicitly.
There is hence no explicit recursion.  This is important, because some
parsers may want to just let the lexer continue matching further input rather
than return a token, whereas others might want to see a token to relate it
grammatically to others.</p>

<h4>
<a id="example-implementation" class="anchor" href="#example-implementation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Example implementation</h4>

<p>The <code>abstract_lexer</code> directory contains the following files:</p>

<ul>
<li><code>lexer.mll</code></li>
<li><code>lexers.ml</code></li>
<li><code>main.ml</code></li>
<li><code>test.dat</code></li>
</ul>

<p>The <code>ocamllex</code> file <code>lexer.mll</code> demonstrates how to wrap a lexer into a
functor.  The signature of the functor argument is <code>Spec</code>.  This specification
introduces a module for each rule in the lexer (e.g. <code>Any_char</code>) containing
an abstract type <code>t</code>.  All rule actions have to return the same type anyway,
and here this type is completely abstract rather than a particular type of
parser tokens.</p>

<p>Now we introduce a function for each pattern action,
e.g. <code>Any_char.handle_char</code>.  It has to take the current <code>lexbuf</code> as argument
so that an instance of the lexer can extract additional lexeme information
(e.g. location information if required), or to allow recursive calls to
other lexer rules.  We may often want to also pass additional arguments,
e.g. particular parts of the lexeme that we have already extracted.  This is
useful if, for example, we attach identifiers to sub-patterns in the lexer
rule.</p>

<p>The functor in <code>lexer.mll</code> is introduced in the header part of the lexer
specification and closed in the trailer, thus wrapping the automatically
generated lexer code into its body.</p>

<p>An example instance of this lexer is given in file <code>lexers.ml</code>.  It is called
<code>Lexers.Alternating</code> and demonstrates how to specify recursive lexer rules.
This is achieved by making the module <code>Alternating</code> itself recursive.</p>

<p>The file <code>main.ml</code> will start lexing from standard input with rule
<code>Lexers.Alternating.any_char</code>.  Valid example input can be found in
file <code>test.dat</code>.  You can compile and test the example by going to the
<code>abstract_lexer</code> directory and executing:</p>

<div class="highlight highlight-source-shell"><pre>ocamlbuild main.native
./main.native <span class="pl-k">&lt;</span> <span class="pl-c1">test</span>.dat</pre></div>

<h4>
<a id="fazit" class="anchor" href="#fazit" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Fazit</h4>

<p>It seems recommendable to write new lexers in an abstract style as demonstrated
above.  This will allow you to completely and cleanly separate the stages
of lexical and syntactic analysis.  If, for example, future requirements
ask for a new parser, you won't have to pollute old parser specifications
with new tokens and dummy rules.</p>

<p>The performance impact of this abstraction will generally be neglible,
assuming the lexer is well-written.  This requires that as much work as
possible is assigned to the lexing engine rather than to pattern actions.
E.g. rules containing a pattern that matches a single character and which
are called recursively to handle input in this piece-wise fashion should be
rewritten to match one complex pattern and perform one action only instead.
This will generally give a great boost to lexer performance, especially if
it is abstract.</p>

<h3>
<a id="extensible-asts" class="anchor" href="#extensible-asts" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Extensible ASTs</h3>

<p>This simple example shows how to implement extensible abstract syntax trees
(ASTs).  It uses polymorphic variants to achieve open recursion and to easily
compose multiple recursive "languages".</p>

<p>See the file <code>ast.ml</code> in directory <code>extensible_ast</code>, which you can compile
as follows:</p>

<div class="highlight highlight-source-shell"><pre>ocamlbuild ast.native</pre></div>

<h3>
<a id="arrows" class="anchor" href="#arrows" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Arrows</h3>

<p>This project in directory <code>arrows</code> mostly translates the Haskell-code
presented in the following paper to OCaml:</p>

<pre><code>Generalising Monads to Arrows
John Hughes
Science of Computer Programming 37, pp67-111, May 2000
</code></pre>

<p>The project contains the following files:</p>

<ul>
<li>
<code>arrow.mli</code> and <code>arrow.ml</code>
</li>
<li><code>arr.ml</code></li>
</ul>

<p>The module <code>Arrow</code> has a fully documented API and provides several simple
implementations for arrows, which can be extended to arrows with more
convenience functions.  The signature of simple arrows specifies the type
of arrows and the following functions:</p>

<ul>
<li>
<code>arr</code> - creates arrows from ordinary functions</li>
<li>
<code>&gt;&gt;&gt;</code> - the arrow composition operator</li>
<li>
<code>app</code> - arrow application</li>
<li>
<code>run</code> - a function to "chase arrows"</li>
</ul>

<p>The <code>arr</code>-function and composition operator are at the core of arrows, but
are not sufficient to give them the same power as e.g. monads.  Adding arrow
application restores this power and allows us to enrich them with numerous
other functions that provide useful programming idioms, e.g. for dealing
with tuples or choice.  Please refer to the above-mentioned paper for details.</p>

<p>The simplest arrow implementation in module <code>SimpleArrow</code> just uses ordinary
functions as representation of arrows.  It suffers from stack overflows
if arrow composition is nested too deeply.  The module <code>SimpleContArrow</code>
fixes this problem by representing arrows with continuations.  Module
<code>SimpleDataContArrow</code> uses sum tags for representing the structure of arrows
and their compositions.  It also uses continuations to avoid stack overflows.</p>

<p>The functor <code>MkArrow</code> takes a simple arrow and enriches it with more
functions as described in John Hughes' paper.  Module <code>Arrow</code> finally also
implements monads by showing how we can obtain one from an arrow supporting
arrow application and vice versa, thus proving their equivalence in terms
of expressive power.</p>

<h3>
<a id="union-find" class="anchor" href="#union-find" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Union find</h3>

<p>The example in directory <code>union_find</code> demonstrates how to implement the
union-find algorithm.  The example uses <em>Generalized Algebraic Datatypes</em>
(GADTs) together with <em>mutable inline records</em> to implement highly efficient
datastructures with fewer indirections and a smaller memory footprint than
usual records and algebraic datatypes would allow.  You will need at least
OCaml 4.04 to unbox away unnecessary data.</p>

<p>You can build the code using:</p>

<div class="highlight highlight-source-shell"><pre>ocamlbuild test_union_find.native</pre></div>

<hr>

<h2>
<a id="contact-information-and-contributing" class="anchor" href="#contact-information-and-contributing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Contact Information and Contributing</h2>

<p>In the case of bugs, feature requests, contributions and similar, you can
contact me here: <a href="mailto:markus.mottl@gmail.com">markus.mottl@gmail.com</a></p>

<p>Up-to-date information concerning this tool should be available at:
<a href="https://mmottl.github.io/ocaml-prog-pats">https://mmottl.github.io/ocaml-prog-pats</a></p>

<p>Enjoy!</p>

<p>Markus Mottl on September 21, 2016</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/mmottl/ocaml-prog-pats">Ocaml-prog-pats</a> is maintained by <a href="https://github.com/mmottl">mmottl</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
